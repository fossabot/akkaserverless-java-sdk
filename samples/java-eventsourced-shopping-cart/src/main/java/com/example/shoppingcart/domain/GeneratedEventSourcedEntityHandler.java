/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.shoppingcart.domain;

// tagging along with Raboofs design from
// https://github.com/lightbend/akkaserverless-java-sdk/pull/73
//

import com.akkaserverless.javasdk.Reply;
import com.akkaserverless.javasdk.eventsourcedentity.CommandContext;
import com.akkaserverless.javasdk.eventsourcedentity.EventContext;
import com.akkaserverless.javasdk.eventsourcedentity.EventSourcedEntityBase;
import com.akkaserverless.javasdk.eventsourcedentity.SnapshotContext;
import com.akkaserverless.javasdk.impl.AnySupport;
import com.akkaserverless.javasdk.impl.EntityExceptions;
import com.akkaserverless.javasdk.lowlevel.EventSourcedEntityHandler;
import com.example.shoppingcart.ShoppingCartApi;
import com.google.protobuf.Any;
import com.google.protobuf.Descriptors;
import com.google.protobuf.GeneratedMessageV3;
import com.google.protobuf.InvalidProtocolBufferException;
import scala.None$;
import scala.Option;

import java.util.Optional;

/**
 * This class would be generated by codegen and should be treated mostly as an implementation detail
 * by the user. No real public API
 *
 * <p>It wraps one instance of the entity and has the generated glue to route incoming calls to the
 * user entity instance keeps track of its state etc.
 *
 * <p>FIXME do we expect to implement this in Java to make it easier to understand for users or
 * Scala to make it easier to implement for us? FIXME I think some of this can be abstracted away
 * and to minimize how much we need to generate
 */
public final class GeneratedEventSourcedEntityHandler implements EventSourcedEntityHandler {
  private final GeneratedCartEntityBaseclass entity;
  private final AnySupport anySupport;
  public static final Descriptors.ServiceDescriptor serviceDescriptor =
      ShoppingCartApi.getDescriptor().findServiceByName("ShoppingCartService");
  private Optional<ShoppingCartDomain.Cart> _state = Optional.empty();

  public GeneratedEventSourcedEntityHandler(GeneratedCartEntityBaseclass entity) {
    this.entity = entity;
    this.anySupport =
        new AnySupport(
            // FIXME what are the actual things to stuff in here
            new Descriptors.FileDescriptor[] {ShoppingCartDomain.getDescriptor()},
            getClass().getClassLoader(),
            AnySupport.DefaultTypeUrlPrefix(),
            AnySupport.PREFER_JAVA());
  }

  @Override
  public Reply<Any> handleCommand(Any command, CommandContext context) {
    try {
      switch (context.commandName()) {
        case "AddItem":
          return replyFromEffect(
              entity.addItem(
                  getState(), ShoppingCartApi.AddLineItem.parseFrom(command.getValue()), context));
        case "RemoveItem":
          return replyFromEffect(
              entity.removeItem(
                  getState(),
                  ShoppingCartApi.RemoveLineItem.parseFrom(command.getValue()),
                  context));
        case "GetCart":
          return replyFromEffect(
              entity.getCart(
                  getState(),
                  ShoppingCartApi.GetShoppingCart.parseFrom(command.getValue()),
                  context));
        default:
          Option<?> noneOption = None$.MODULE$;
          throw new EntityExceptions.EntityException(
              context.entityId(),
              context.commandId(),
              context.commandName(),
              "No command handler found for command ["
                  + context.commandName()
                  + "] on "
                  + entity.getClass().toString(),
              (Option<Throwable>) noneOption);
      }
    } catch (InvalidProtocolBufferException ex) {
      throw new RuntimeException(
          "Invalid protocol buffer message for command " + context.commandName());
    }
  }

  @Override
  public void handleEvent(Any anyEvent, EventContext context) {
    // TODO we used to support passing in the command as Jackson-parsed model object or as ScalaPB
    Object event = anySupport.decode(anyEvent);
    if (event instanceof ShoppingCartDomain.ItemAdded) {
      setState(entity.itemAdded(getState(), (ShoppingCartDomain.ItemAdded) event, context));
    } else if (event instanceof ShoppingCartDomain.ItemRemoved) {
      setState(entity.itemRemoved(getState(), (ShoppingCartDomain.ItemRemoved) event, context));
    } else {
      throw new IllegalArgumentException("Unknown event type [" + event.getClass() + "]");
    }
  }

  @Override
  public void handleSnapshot(Any anySnapshot, SnapshotContext context) {
    Object snapshot = anySupport.decode(anySnapshot);
    if (snapshot instanceof ShoppingCartDomain.Cart) {
      setState((ShoppingCartDomain.Cart) snapshot);
    } else {
      throw new IllegalArgumentException("Unknown type of snapshot [" + snapshot.getClass() + "]");
    }
  }

  @Override
  public Optional<Any> snapshot(SnapshotContext context) {
    return _state.map(anySupport::encodeJava);
  }

  private void setState(ShoppingCartDomain.Cart cart) {
    this._state = Optional.of(cart);
  }

  private ShoppingCartDomain.Cart getState() {
    if (_state.isEmpty()) {
      _state = Optional.of(entity.emptyState());
    }
    return _state.get();
  }

  private static <T> Reply<Any> replyFromEffect(EventSourcedEntityBase.Effect<T> effect) {
    // FIXME this needs an update in EventSourcedEntityHandler to expect effect first rather than
    // live here
    throw new UnsupportedOperationException("FIXME");
  }
}
